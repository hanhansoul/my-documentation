# greenlet:轻量级的并发编程

greelet指的是使用一个任务调度器和一些生成器或者协程实现协作式用户空间多线程的一种伪并发机制，即所谓的微线程。

greelet机制的主要思想是：生成器函数或者协程函数中的yield语句挂起函数的执行，直到稍后使用next()或send()操作进行恢复为止。可以使用一个调度器循环在一组生成器函数之间协作多个任务。

网络框架的几种基本的网络I/O模型：

1. 阻塞式单线程：这是最基本的I/O模型，只有在处理完一个请求之后才会处理下一个请求。
2. 阻塞式多线程：针对于单线程接受请求量有限的缺点，一个很自然的想法就是给每一个请求开一个线程去处理。
3. 非阻塞式事件驱动：为了解决多线程的问题，有一种做法是利用一个循环来检查是否有网络IO的事件发生，以便决定如何来进行处理（reactor设计模式）。
4. 非阻塞式Coroutine（协程）：这个模式是为了解决事件驱动模型执行流程不直观的问题，它在本质上也是事件驱动的，加入了Coroutine的概念。



## 与线程/进程的区别

线程是抢占式的调度，多个线程并行执行，抢占共同的系统资源；而微线程是协同式的调度。

其实greenlet不是一种真正的并发机制，而是在同一线程内，在不同函数的执行代码块之间切换，实施“你运行一会、我运行一会”，并且在进行切换时必须指定何时切换以及切换到哪。greenlet的接口是比较简单易用的，但是使用greenlet时的思考方式与其他并发方案存在一定区别：

1. 线程/进程模型在大逻辑上通常从并发角度开始考虑，把能够并行处理的并且值得并行处理的任务分离出来，在不同的线程/进程下运行，然后考虑分离过程可能造成哪些互斥、冲突问题，将互斥的资源加锁保护来保证并发处理的正确性。
2. greenlet则是要求从避免阻塞的角度来进行开发，当出现阻塞时，就显式切换到另一段没有被阻塞的代码段执行，直到原先的阻塞状况消失以后，再人工切换回原来的代码段继续处理。因此，greenlet本质是一种合理安排了的 **串行** 。
3. greenlet本质是串行，因此在没有进行显式切换时，代码的其他部分是无法被执行到的，如果要避免代码长时间占用运算资源造成程序假死，那么还是要将greenlet与线程/进程机制结合使用（每个线程、进程下都可以建立多个greenlet，但是跨线程/进程时greenlet之间无法切换或通讯）。



## eventlet

eventlet 是基于 greenlet 实现的面向网络应用的并发处理框架，提供“线程”池、队列等与其他 Python 线程、进程模型非常相似的 api，并且提供了对 Python 发行版自带库及其他模块的超轻量并发适应性调整方法，比直接使用 greenlet 要方便得多。

其基本原理是调整 Python 的 socket 调用，当发生阻塞时则切换到其他 greenlet 执行，这样来保证资源的有效利用。需要注意的是：

1. eventlet 提供的函数只能对 Python 代码中的 socket 调用进行处理，而不能对模块的 C 语言部分的 socket 调用进行修改。对后者这类模块，仍然需要把调用模块的代码封装在 Python 标准线程调用中，之后利用 eventlet 提供的适配器实现 eventlet 与标准线程之间的协作。

2. 虽然 eventlet 把 api 封装成了非常类似标准线程库的形式，但两者的实际并发执行流程仍然有明显区别。在没有出现 I/O 阻塞时，除非显式声明，否则当前正在执行的 eventlet 永远不会把 cpu 交给其他的 eventlet，而标准线程则是无论是否出现阻塞，总是由所有线程一起争夺运行资源。所有 eventlet 对 I/O 阻塞无关的大运算量耗时操作基本没有什么帮助。



## gevent

 gevent是一个基于协程（coroutine）的Python网络函数库，通过使用greenlet提供了一个在libev事件循环顶部的高级别并发API。

主要特性有以下几点：

- 基于libev的快速事件循环，Linux上面的是epoll机制
- 基于greenlet的轻量级执行单元
- API复用了Python标准库里的内容
- 支持SSL的协作式sockets
- 可通过线程池或c-ares实现DNS查询
- 通过monkey patching功能来使得第三方模块变成协作式